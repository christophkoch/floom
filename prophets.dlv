node(n1).
node(n2).

ts(N, T) :- node(N), #int(T). % logical timestamps per node




%%%%%%%%%%%%%%%%%%%%%%
% possible serializations

before(N, T1, N, T2) :- ts(N, T1), ts(N, T2), T1 < T2.

% possible relative orderings of timestamps on logical clocks of two nodes
before(N1, T1, N2, T2) v before(N2, T2, N1, T1) :-  ts(N1, T1), ts(N2, T2), N1 != N2.

% antisymmetry of ordering; this constraint never fires in this encoding and could be removed
argh :- before(N1, T1, N2, T2), before(N2, T2, N1, T1).

% transitivity of ordering
before(N1, T1, N3, T3) :- before(N1, T1, N2, T2), before(N2, T2, N3, T3), N1 != N3.


succ(N1, T1, N2, T2) :- before(N1, T1, N2, T2), not exists_between(N1, T1, N2, T2).
exists_between(N1, T1, N3, T3) :- before(N1, T1, N2, T2), before(N2, T2, N3, T3).

% among the Ts of N2, T2 is the one closest following T1@N1.
% This is not the successor relation
next(N1, T1, N2, T2) :- before(N1, T1, N2, T2), not exists_between2(N1, T1, N2, T2).
exists_between2(N1, T1, N3, T3) :- before(N1, T1, N3, T2), before(N3, T2, N3, T3).




%%%%%%%%%%%%%%%%%%%%%%
% receiving a mesg sent by
% sent(Sender, SenderT, Receiver, MesgID, MesgParameter)
% optionally picking one is several of the same type are received at the same time.

received(Sender, SenderT, Receiver, ReceiverT, Mesg, MParam)
% v lost(Sender, SenderT, Receiver,            Mesg, MParam)
 :- sent(Sender, SenderT, Receiver,            Mesg, MParam),
    next(Sender, SenderT, Receiver, ReceiverT).


% if received multiple in same tick, pick exactly one.
 pick_received(Sender, SenderT, Receiver, ReceiverT, Mesg, MParam) v
-pick_received(Sender, SenderT, Receiver, ReceiverT, Mesg, MParam) :-
      received(Sender, SenderT, Receiver, ReceiverT, Mesg, MParam).

% at most one pick
:- pick_received(_, _, Receiver, ReceiverT, Mesg, V1),
   pick_received(_, _, Receiver, ReceiverT, Mesg, V2), V1 != V2.

% at least one pick
:- received(_, _, Receiver, ReceiverT, Mesg, _), not some_pick(Receiver, ReceiverT, Mesg).
some_pick(Receiver, ReceiverT, Mesg) :- pick_received(_, _, Receiver, ReceiverT, Mesg, _).

% can override pick by setting pick_received, see example below.




%%%%%%%%%%%%%%%%%%%%%%
% kv is a key-value store with only one key (implicit). easy to generalize.

% client writes to the kv store
set(n1, 0, a).
set(n2, 0, b).


sent(N0, T0, N, kv_set, V) :- set(N0, T0, V), node(N), N != N0.

% override: local set takes priority over received.
pick_received(N, T, N, T, kv_set, V) :- set(N, T, V).

% set new value
kv(N, T, V) :- pick_received(_, _, N, T, kv_set, V).

% inertia: if no change, keep value
kv(N, T, V) :- kv(N, T0, V), next(N, T0, N, T), not some_pick(N, T, kv_set).



% bad worlds in which kv is not consistent in the final state
bad(N1, V1, N2, V2) :- kv(N1, T, V1), kv(N2, T, V2), V1 != V2, max(T), N1 < N2.
max(X) :- #int(X), not has_gt(X).
has_gt(X) :- #int(X), #int(Y), X < Y.




%%%%%%%%%%%%%%%%%%%%%%
% Paxos

% client request
request(n1, 2).

%note: the proposer is among the acceptors
sent(Proposer, Prop_T, Acceptor, prepare, V) :- kv(Proposer, Prop_T, V),
  request(Proposer, Prop_T), node(Acceptor), not paxos_running(Proposer).

sent0(Acceptor, Proposer, promise, V) :- pick_received(Proposer, _, Acceptor, T, prepare, V).

% simplification. paxos only started once, protocol completely executes immediately (time stamp of start)
paxos_running(Acceptor) :- pick_received(_, _, Acceptor, _, prepare, _).


% universal quantification: all have sent
exists_sent0(Sender, Receiver, Mesg) :- sent0(Sender, Receiver, Mesg, _).
missing_sent0(Receiver, Mesg) :- sent0(Sender, _, Mesg, _), node(Receiver),
                                 not exists_sent0(Sender, Receiver, Mesg).
all_have_sent0(Receiver, Mesg) :- exists_sent0(_, Receiver, Mesg),
                                  not missing_sent0(Receiver, Mesg).
% if at least one has sent: not vacuously true -- for rule safety.

sent0(Proposer, Acceptor, do_accept, V) :- sent0(Acceptor, Proposer, promise, V),
                                           all_have_sent0(Proposer, promise).

sent0(Acceptor, Learner, accepted, V) :- sent0(_, Acceptor, do_accept, V), node(Learner).

answer(Learner, V) :- all_have_sent0(Learner, accepted), sent0(_, Learner, accepted, V).

bad_paxos(V1, V2) :- answer(N1, V1), answer(N2, V2), V1 != V2.

% look for bugs
exists_bad_paxos :- bad_paxos(_, _).
:- not exists_bad_paxos.


